# name: test/sql/sqlpgq/shortest_path_bound.test
# group: [sqlpgq]

statement ok
pragma enable_verification

require duckpgq

# Graph to test regular shortest path bound
# (0) -> (1)
#  ↓      ↑
# (2) -> (3)

statement ok
CREATE TABLE Point(id BIGINT); INSERT INTO Point VALUES (0), (1), (2), (3);

statement ok
CREATE TABLE know(src BIGINT, dst BIGINT); INSERT INTO know VALUES (0, 1), (0, 2), (2, 3), (3, 1);

statement ok
-CREATE PROPERTY GRAPH pg
VERTEX TABLES (
    Point PROPERTIES ( id ) LABEL Pnt
    )
EDGE TABLES (
    know    SOURCE KEY ( src ) REFERENCES Point ( id )
            DESTINATION KEY ( dst ) REFERENCES Point ( id )
            LABEL Knows
    );

query III
WITH cte1 AS (
    SELECT  CREATE_CSR_EDGE(
            0,
            (SELECT count(a.id) FROM Point a),
            CAST (
                (SELECT sum(CREATE_CSR_VERTEX(
                            0,
                            (SELECT count(a.id) FROM Point a),
                            sub.dense_id,
                            sub.cnt)
                            )
                FROM (
                    SELECT a.rowid as dense_id, count(k.src) as cnt
                    FROM Point a
                    LEFT JOIN Know k ON k.src = a.id
                    GROUP BY a.rowid) sub
                )
            AS BIGINT),
            a.rowid,
            c.rowid,
            k.rowid) as temp
    FROM Know k
    JOIN Point a on a.id = k.src
    JOIN Point c on c.id = k.dst
) SELECT a.id as srd_id, b.id as dst_id, shortestpath_lowerbound(0, (select count(*) from Point), a.rowid, b.rowid, 2, 3) as path
        FROM Point a, Point b, (select count(cte1.temp) * 0 as temp from cte1) __x
        WHERE a.id = 0 and __x.temp * 0 + iterativelength_lowerbound(0, (select count(*) from Point), a.rowid, b.rowid, 2, 3);
----
0	1	[0, 1, 2, 2, 3, 3, 1]
0	3	[0, 1, 2, 2, 3]

query III
WITH cte1 AS (
    SELECT  CREATE_CSR_EDGE(
            0,
            (SELECT count(a.id) FROM Point a),
            CAST (
                (SELECT sum(CREATE_CSR_VERTEX(
                            0,
                            (SELECT count(a.id) FROM Point a),
                            sub.dense_id,
                            sub.cnt)
                            )
                FROM (
                    SELECT a.rowid as dense_id, count(k.src) as cnt
                    FROM Point a
                    LEFT JOIN Know k ON k.src = a.id
                    GROUP BY a.rowid) sub
                )
            AS BIGINT),
            a.rowid,
            c.rowid,
            k.rowid) as temp
    FROM Know k
    JOIN Point a on a.id = k.src
    JOIN Point c on c.id = k.dst
) SELECT a.id, b.id, shortestpath_lowerbound(0, (select count(*) from Point), a.rowid, b.rowid, 1, 3) as path
        FROM Point a, Point b, (select count(cte1.temp) * 0 as temp from cte1) __x
        WHERE a.id = 0 and __x.temp * 0 + iterativelength(0, (select count(*) from Point), a.rowid, b.rowid, 1, 3);
----
0	1	[0, 0, 1]
0	2	[0, 1, 2]
0	3	[0, 1, 2, 2, 3]

# Graph to test shortest path bound with a cycle
# (0) --> (1) <-> (2)
# 0 to 1 is 1 hop

statement ok
CREATE TABLE Point2(id BIGINT); INSERT INTO Point2 VALUES (0), (1), (2);

statement ok
CREATE TABLE know2(src BIGINT, dst BIGINT); INSERT INTO know2 VALUES (0, 1), (1, 2), (2, 1);

statement ok
-CREATE PROPERTY GRAPH pg2
VERTEX TABLES (
    Point2 PROPERTIES ( id ) LABEL Pnt2
    )
EDGE TABLES (
    know2   SOURCE KEY ( src ) REFERENCES Point2 ( id )
            DESTINATION KEY ( dst ) REFERENCES Point2 ( id )
            LABEL Knows2
    );

query III
WITH cte1 AS (
    SELECT  CREATE_CSR_EDGE(
            0,
            (SELECT count(a.id) FROM Point2 a),
            CAST (
                (SELECT sum(CREATE_CSR_VERTEX(
                            0,
                            (SELECT count(a.id) FROM Point2 a),
                            sub.dense_id,
                            sub.cnt)
                            )
                FROM (
                    SELECT a.rowid as dense_id, count(k.src) as cnt
                    FROM Point2 a
                    LEFT JOIN know2 k ON k.src = a.id
                    GROUP BY a.rowid) sub
                )
            AS BIGINT),
            a.rowid,
            c.rowid,
            k.rowid) as temp
    FROM know2 k
    JOIN Point2 a on a.id = k.src
    JOIN Point2 c on c.id = k.dst
) SELECT a.id, b.id, shortestpath_lowerbound(0, (select count(*) from Point2), a.rowid, b.rowid, 2, 30) as path
        FROM Point2 a, Point2 b, (select count(cte1.temp) * 0 as temp from cte1) __x
        WHERE a.id = 0 and __x.temp * 0 + iterativelength_lowerbound(0, (select count(*) from Point2), a.rowid, b.rowid, 2, 30);
----
0	1	[0, 0, 1, 1, 2, 2, 1]
0	2	[0, 0, 1, 1, 2]


# Graph to test shortest path bound with a cycle
# (1) <- (0) <-> (2)
# 0 to 1 is 1 hop

statement ok
CREATE TABLE Point3(id BIGINT); INSERT INTO Point3 VALUES (0), (1), (2);

statement ok
CREATE TABLE know3(src BIGINT, dst BIGINT); INSERT INTO know3 VALUES (0, 1), (0, 2), (2, 0);

statement ok
-CREATE PROPERTY GRAPH pg3
VERTEX TABLES (
    Point3 PROPERTIES ( id ) LABEL Pnt
    )
EDGE TABLES (
    know3    SOURCE KEY ( src ) REFERENCES Point3 ( id )
            DESTINATION KEY ( dst ) REFERENCES Point3 ( id )
            LABEL Knows
    );

query III
WITH cte1 AS (
    SELECT  CREATE_CSR_EDGE(
            0,
            (SELECT count(a.id) FROM Point3 a),
            CAST (
                (SELECT sum(CREATE_CSR_VERTEX(
                            0,
                            (SELECT count(a.id) FROM Point3 a),
                            sub.dense_id,
                            sub.cnt)
                            )
                FROM (
                    SELECT a.rowid as dense_id, count(k.src) as cnt
                    FROM Point3 a
                    LEFT JOIN know3 k ON k.src = a.id
                    GROUP BY a.rowid) sub
                )
            AS BIGINT),
            a.rowid,
            c.rowid,
            k.rowid) as temp
    FROM know3 k
    JOIN Point3 a on a.id = k.src
    JOIN Point3 c on c.id = k.dst
) SELECT a.id, b.id, shortestpath_lowerbound(0, (select count(*) from Point3), a.rowid, b.rowid, 2, 3) as path
        FROM Point3 a, Point3 b, (select count(cte1.temp) * 0 as temp from cte1) __x
        WHERE __x.temp * 0 + iterativelength_lowerbound(0, (select count(*) from Point3), a.rowid, b.rowid, 2, 3);
----
0	0	[0, 1, 2, 2, 0]
0	1	[0, 1, 2, 2, 0, 0, 1]
0	2	[0, 1, 2, 2, 0, 1, 2]
2	0	[2, 2, 0, 1, 2, 2, 0]
2	1	[2, 2, 0, 0, 1]
2	2	[2, 2, 0, 1, 2]

# Graph to test shortest path bound with a cycle
# (1) <- (0) <-> (2)

statement ok
CREATE TABLE Point4(id BIGINT); INSERT INTO Point4 VALUES (0), (1), (2);

statement ok
CREATE TABLE know4(src BIGINT, dst BIGINT); INSERT INTO know4 VALUES (0, 1), (0, 2), (2, 0);

statement ok
-CREATE PROPERTY GRAPH pg4
VERTEX TABLES (
    Point4 PROPERTIES ( id ) LABEL Point4
    )
EDGE TABLES (
    know4    SOURCE KEY ( src ) REFERENCES Point4 ( id )
            DESTINATION KEY ( dst ) REFERENCES Point4 ( id )
            LABEL know4
    );

query III
-FROM GRAPH_TABLE (pg4
    MATCH
    p = ANY SHORTEST (a:Point4)-[k:know4]->{2,3}(b:Point4)
    COLUMNS (a.id AS id1, b.id AS id2, element_id(p))
    ) tmp
    ORDER BY tmp.id1, tmp.id2;
----
0	0	[0, 1, 2, 2, 0]
0	1	[0, 1, 2, 2, 0, 0, 1]
0	2	[0, 1, 2, 2, 0, 1, 2]
2	0	[2, 2, 0, 1, 2, 2, 0]
2	1	[2, 2, 0, 0, 1]
2	2	[2, 2, 0, 1, 2]

query IIIII
-FROM GRAPH_TABLE (pg4
    MATCH
    p = ANY SHORTEST (a:Point4)-[k:know4]->{1,5}(b:Point4)
    COLUMNS (a.id as id1, b.id as id2, element_id(p) as elements, vertices(p) as vertices, path_length(p) as length)
    ) tmp
    order by tmp.id1, tmp.id2;
----
0	0	[0, 1, 2, 2, 0]	[0, 2, 0]	2
0	1	[0, 0, 1]	[0, 1]	1
0	2	[0, 1, 2]	[0, 2]	1
2	0	[2, 2, 0]	[2, 0]	1
2	1	[2, 2, 0, 0, 1]	[2, 0, 1]	2
2	2	[2, 2, 0, 1, 2]	[2, 0, 2]	2

query IIIII
-FROM GRAPH_TABLE (pg4
    MATCH
    p = ANY SHORTEST (a:Point4)-[k:know4]->{10,15}(b:Point4)
    COLUMNS (a.id as id1, b.id as id2, element_id(p) as elements, vertices(p) as vertices, path_length(p) as length)
    ) tmp
    order by tmp.id1, tmp.id2;
----
0	0	[0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0]	[0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0]	10
0	1	[0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 0, 1]	[0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1]	11
0	2	[0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2]	[0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2]	11
2	0	[2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0]	[2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0]	11
2	1	[2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 0, 1]	[2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1]	10
2	2	[2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2, 2, 0, 1, 2]	[2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2]	10

# Description: Test algorithm's capability to ignore isolated nodes.
# (0) <-> (2), (1), (3)

statement ok
CREATE TABLE Point5(id BIGINT); INSERT INTO Point5 VALUES (0), (1), (2), (3);

statement ok
CREATE TABLE know5(src BIGINT, dst BIGINT); INSERT INTO know5 VALUES (0, 2), (2, 0);

statement ok
-CREATE PROPERTY GRAPH pg5
VERTEX TABLES (
    Point5 PROPERTIES ( id ) LABEL Point5
)
EDGE TABLES (
    know5 SOURCE KEY ( src ) REFERENCES Point5 ( id )
          DESTINATION KEY ( dst ) REFERENCES Point5 ( id )
          LABEL know5
);

query III
-FROM GRAPH_TABLE (pg5
    MATCH
    p = ANY SHORTEST (a:Point5)-[k:know5]->{2,3}(b:Point5)
    COLUMNS (a.id, b.id, element_id(p))
) tmp;
----
0	0	[0, 0, 2, 1, 0]
2	0	[2, 1, 0, 0, 2, 1, 0]
0	2	[0, 0, 2, 1, 0, 0, 2]
2	2	[2, 1, 0, 0, 2]

# Description: Test shortest paths in a graph with cycles.
# (0) <-> (2) <-> (3) -> (1) ⮌
#  ↑                      |
#  └----------------------┘

statement ok
CREATE TABLE Point6(id BIGINT); INSERT INTO Point6 VALUES (0), (1), (2), (3);

statement ok
CREATE TABLE know6(src BIGINT, dst BIGINT); INSERT INTO know6 VALUES (0, 2), (2, 0), (2, 3), (3, 2), (3, 1), (1, 0), (1, 1);

statement ok
-CREATE PROPERTY GRAPH pg6
VERTEX TABLES (
    Point6 PROPERTIES ( id ) LABEL Point6
)
EDGE TABLES (
    know6 SOURCE KEY ( src ) REFERENCES Point6 ( id )
          DESTINATION KEY ( dst ) REFERENCES Point6 ( id )
          LABEL know6
);

query III
-FROM GRAPH_TABLE (pg6
    MATCH
    p = ANY SHORTEST (a:Point6)-[k:know6]->{2,4}(b:Point6)
    COLUMNS (a.id as id1, b.id as id2, element_id(p))
	) tmp
	order by tmp.id1, tmp.id2;
----
0	0	[0, 0, 2, 1, 0]
0	1	[0, 0, 2, 2, 3, 4, 1]
0	2	[0, 0, 2, 1, 0, 0, 2]
0	3	[0, 0, 2, 2, 3]
1	0	[1, 6, 1, 5, 0]
1	1	[1, 6, 1, 6, 1]
1	2	[1, 5, 0, 0, 2]
1	3	[1, 5, 0, 0, 2, 2, 3]
2	0	[2, 2, 3, 4, 1, 5, 0]
2	1	[2, 2, 3, 4, 1]
2	2	[2, 1, 0, 0, 2]
2	3	[2, 1, 0, 0, 2, 2, 3]
3	0	[3, 4, 1, 5, 0]
3	1	[3, 4, 1, 6, 1]
3	2	[3, 4, 1, 5, 0, 0, 2]
3	3	[3, 3, 2, 2, 3]


query IIII
-FROM GRAPH_TABLE (pg6
    MATCH
    p = ANY SHORTEST (a:Point6 where a.id = 0)-[k:know6]->{1,3}(b:Point6 where b.id = 0)
    COLUMNS (a.id as id1, b.id as id2, vertices(p), path_length(p))
	) tmp
	order by tmp.id1, tmp.id2;
----
0	0	[0, 2, 0]	2

query IIII
-FROM GRAPH_TABLE (pg6
    MATCH
    p = ANY SHORTEST (a:Point6 where a.id = 1)-[k:know6]->{1,3}(b:Point6 where b.id = 1)
    COLUMNS (a.id as id1, b.id as id2, vertices(p), path_length(p))
	) tmp
	order by tmp.id1, tmp.id2;
----
1	1	[1, 1]	1